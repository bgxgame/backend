This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env_template
.gitignore
Cargo.toml
data.json
init_schema.sql
README.md
register.json
register2.json
src/auth.rs
src/error.rs
src/handlers.rs
src/main.rs
src/models.rs
src/validation.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env_template">
# æ•°æ®åº“è¿æ¥ URL
DATABASE_URL=postgres://ç”¨æˆ·å:å¯†ç @åœ°å€:ç«¯å£/æ•°æ®åº“å
# æ—¥å¿—çº§åˆ«
RUST_LOG=debug
# JWT å¯†é’¥
JWT_SECRET=xxxxxxxxxxxxxxxxxxxxxxxxxxx
</file>

<file path="data.json">
{
  "title": "å­¦ä¹  Rust",
  "description": "å®Œæˆ CRUD æ¥å£å¼€å‘",
  "category": "work"
}
</file>

<file path="init_schema.sql">
-- 1. æ¸…ç†æ—§è¡¨
DROP TABLE IF EXISTS issues;
DROP TABLE IF EXISTS projects;
DROP TABLE IF EXISTS users;

-- 2. åˆ›å»ºç”¨æˆ·è¡¨
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 3. åˆ›å»ºé¡¹ç›®è¡¨ (Project)
CREATE TABLE projects (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    
    -- é¡¹ç›®çŠ¶æ€: backlog(ç§¯å‹), active(æ¿€æ´»), completed(å®Œæˆ), paused(æš‚åœ), canceled(å–æ¶ˆ)
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    
    -- è§†è§‰æ ‡è¯† (Linear é£æ ¼å¸¸ç”¨)
    color VARCHAR(7) DEFAULT '#5E6AD2', -- é¡¹ç›®ä¸»é¢˜è‰²
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 4. åˆ›å»ºä»»åŠ¡è¡¨ (Issue)
CREATE TABLE issues (
    id SERIAL PRIMARY KEY,
    project_id INTEGER NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE, -- åˆ›å»ºè€…/è´Ÿè´£äºº
    
    title VARCHAR(255) NOT NULL,
    description TEXT, -- æ”¯æŒ Markdown
    
    -- ä»»åŠ¡çŠ¶æ€: backlog, todo, in_progress, done, canceled
    status VARCHAR(20) NOT NULL DEFAULT 'todo',
    
    -- ä¼˜å…ˆçº§: 0(æ— ), 1(ä½), 2(ä¸­), 3(é«˜), 4(ç´§æ€¥)
    priority INTEGER NOT NULL DEFAULT 0,
    
    due_date TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 5. åˆ›å»ºç´¢å¼•æé«˜æŸ¥è¯¢æ•ˆç‡
CREATE INDEX idx_projects_user_id ON projects(user_id);
CREATE INDEX idx_issues_project_id ON issues(project_id);
CREATE INDEX idx_issues_user_id ON issues(user_id);

-- 6. è‡ªåŠ¨æ›´æ–° updated_at çš„è§¦å‘å™¨å‡½æ•° (PostgreSQL ç‰¹è‰²)
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_projects_modtime BEFORE UPDATE ON projects FOR EACH ROW EXECUTE PROCEDURE update_modified_column();
CREATE TRIGGER update_issues_modtime BEFORE UPDATE ON issues FOR EACH ROW EXECUTE PROCEDURE update_modified_column();


CREATE TABLE refresh_tokens (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
</file>

<file path="register.json">
{ "username": "admin", "password": "mypassword123" }
</file>

<file path=".gitignore">
/target
.env
</file>

<file path="register2.json">
{ "username": "brace3", "password": "myp" }
</file>

<file path="src/validation.rs">
// src/validation.rs
use axum::{
    async_trait,
    extract::{FromRequest, Request}, // ä¿®æ­£ä¸º Request
    Json,
};
use validator::Validate;
use crate::AppError;

pub struct ValidatedJson<T>(pub T);

#[async_trait]
impl<S, T> FromRequest<S> for ValidatedJson<T>
where
    S: Send + Sync,
    T: Validate + serde::de::DeserializeOwned + 'static, // å¢åŠ  'static çº¦æŸ
{
    type Rejection = AppError;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        // 1. åˆ©ç”¨ Axum åŸç”Ÿçš„ Json æå–å™¨è§£æ Body
        // å¦‚æœ JSON æ ¼å¼éæ³•ï¼ˆæ¯”å¦‚å°‘æ‹¬å·ï¼‰ï¼Œè¿™é‡Œä¼šç›´æ¥è¿”å› BadRequest
        let Json(value) = Json::<T>::from_request(req, state).await
            .map_err(|rejection| AppError::BadRequest(rejection.body_text()))?;
        
        // 2. æ‰§è¡Œ validator çš„æ ¡éªŒé€»è¾‘
        // å¦‚æœæ ¡éªŒå¤±è´¥ï¼ˆæ¯”å¦‚æ ‡é¢˜å¤ªçŸ­ï¼‰ï¼Œä¼šé€šè¿‡ AppError::ValidationError è‡ªåŠ¨è½¬æ¢
        value.validate()?; 
        
        Ok(ValidatedJson(value))
    }
}
</file>

<file path="Cargo.toml">
[package]
name = "my-life-planner"
version = "0.1.0"
edition = "2021"

[dependencies]
# Web æ¡†æ¶
axum = "0.7"

# å¼‚æ­¥è¿è¡Œæ—¶ (Rust çš„å¼‚æ­¥å¼•æ“)
tokio = { version = "1", features = ["full"] }

# æ•°æ®åº“é©±åŠ¨ (PostgreSQL)
# runtime-tokio: æŒ‡å®šå¼‚æ­¥è¿è¡Œæ—¶
# tls-native-tls: å¤„ç†æ•°æ®åº“è¿æ¥çš„åŠ å¯†
sqlx = { version = "0.7", features = ["runtime-tokio", "tls-native-tls", "postgres", "chrono", "uuid"] }

# åºåˆ—åŒ–/ååºåˆ—åŒ– (JSONå¤„ç†)
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# ç¯å¢ƒå˜é‡è¯»å–
dotenvy = "0.15"

#å¤„ç†æ•°æ®åº“ä¸­çš„æ—¶é—´å­—æ®µ
chrono = { version = "0.4", features = ["serde"] }

# æ—¥å¿—è¿½è¸ª
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

argon2 = "0.5"
rand_core = { version = "0.6", features = ["std"] }
jsonwebtoken = "9"
axum-extra = { version = "0.9", features = ["typed-header"] }
headers = "0.4"

tower-http = { version = "0.5", features = ["cors"] }

thiserror = "1.0"

validator = { version = "0.19", features = ["derive"] }

uuid = { version = "1", features = ["v4"] }
</file>

<file path="README.md">
# My-Life-Planner é¡¹ç›®ç³»ç»Ÿæ¢³ç†ä¸æ€»ç»“

æ ¹æ®å¯¹é¡¹ç›®çš„å…¨é¢åˆ†æï¼Œä»¥ä¸‹æ˜¯"My-Life-Planner"ï¼ˆæˆ‘çš„ç”Ÿæ´»è®¡åˆ’å™¨ï¼‰é¡¹ç›®çš„ç³»ç»Ÿæ¢³ç†ä¸æ€»ç»“ï¼š

## 1. é¡¹ç›®æ¦‚è¿°

è¿™æ˜¯ä¸€ä¸ªåŸºäºRustå’ŒAxumæ¡†æ¶å¼€å‘çš„ç”Ÿæ´»è®¡åˆ’ç®¡ç†åç«¯ç³»ç»Ÿï¼Œæ—¨åœ¨å¸®åŠ©ç”¨æˆ·ç®¡ç†ä¸ªäººè®¡åˆ’å’Œä»»åŠ¡ã€‚é¡¹ç›®é‡‡ç”¨ç°ä»£åŒ–çš„WebæŠ€æœ¯æ ˆï¼Œæä¾›äº†å®Œæ•´çš„ç”¨æˆ·è®¤è¯å’Œè®¡åˆ’ç®¡ç†åŠŸèƒ½ã€‚

## 2. æŠ€æœ¯æ ˆ

- **Webæ¡†æ¶**: Axum (Rust)
- **å¼‚æ­¥è¿è¡Œæ—¶**: Tokio
- **æ•°æ®åº“**: PostgreSQL (é€šè¿‡SQLx)
- **æ•°æ®åºåˆ—åŒ–**: Serde/serde_json
- **å¯†ç å“ˆå¸Œ**: Argon2
- **JWTè®¤è¯**: jsonwebtoken
- **æ—¥å¿—è¿½è¸ª**: tracing
- **CORSæ”¯æŒ**: tower-http

## 3. æ ¸å¿ƒåŠŸèƒ½

### 3.1 ç”¨æˆ·ç³»ç»Ÿ
- **ç”¨æˆ·æ³¨å†Œ**: åˆ›å»ºæ–°ç”¨æˆ·è´¦å·ï¼Œå¯†ç ä½¿ç”¨Argon2åŠ å¯†å­˜å‚¨
- **ç”¨æˆ·ç™»å½•**: éªŒè¯ç”¨æˆ·èº«ä»½å¹¶ç”ŸæˆJWTä»¤ç‰Œ

### 3.2 è®¡åˆ’ç®¡ç†
- **åˆ›å»ºè®¡åˆ’**: ç”¨æˆ·å¯ä»¥åˆ›å»ºæ–°çš„è®¡åˆ’/ä»»åŠ¡
- **è·å–è®¡åˆ’**: å¯ä»¥è·å–å…¬å¼€çš„è®¡åˆ’åˆ—è¡¨
- **æ›´æ–°è®¡åˆ’**: ä¿®æ”¹å·²æœ‰çš„è®¡åˆ’ä¿¡æ¯
- **åˆ é™¤è®¡åˆ’**: åˆ é™¤æŒ‡å®šçš„è®¡åˆ’

### 3.3 æƒé™æ§åˆ¶
- **å…¬å¼€/ç§æœ‰**: è®¡åˆ’å¯ä»¥è®¾ç½®ä¸ºå…¬å¼€æˆ–ç§æœ‰
- **èº«ä»½éªŒè¯**: å—ä¿æŠ¤çš„APIç«¯ç‚¹éœ€è¦æœ‰æ•ˆçš„JWTä»¤ç‰Œ

## 4. æ•°æ®æ¨¡å‹

### ç”¨æˆ·è¡¨ (users)
- ID (ä¸»é”®ï¼Œè‡ªå¢)
- ç”¨æˆ·å (å”¯ä¸€)
- å¯†ç å“ˆå¸Œ (ä½¿ç”¨Argon2åŠ å¯†)
- åˆ›å»ºæ—¶é—´

### è®¡åˆ’è¡¨ (plans)
- ID (ä¸»é”®ï¼Œè‡ªå¢)
- ç”¨æˆ·ID (å¤–é”®ï¼Œå…³è”ç”¨æˆ·è¡¨)
- æ ‡é¢˜
- æè¿°
- çŠ¶æ€ (å¾…åŠã€è¿›è¡Œä¸­ã€å·²å®Œæˆã€å½’æ¡£)
- åˆ†ç±» (å·¥ä½œã€ç”Ÿæ´»ã€å­¦ä¹ ç­‰)
- ä¼˜å…ˆçº§
- æˆªæ­¢æ—¥æœŸ
- å…¬å¼€æ€§ (å…¬å¼€/ç§æœ‰)
- åˆ›å»ºå’Œæ›´æ–°æ—¶é—´

## 5. APIç«¯ç‚¹

- `GET /api/plans` - è·å–å…¬å¼€è®¡åˆ’åˆ—è¡¨ï¼ˆå¯é€‰è®¤è¯ï¼Œç™»å½•åå¯çœ‹åˆ°è‡ªå·±çš„ç§æœ‰è®¡åˆ’ï¼‰
- `POST /api/register` - ç”¨æˆ·æ³¨å†Œ
- `POST /api/login` - ç”¨æˆ·ç™»å½•
- `POST /api/plans` - åˆ›å»ºæ–°è®¡åˆ’ï¼ˆéœ€è®¤è¯ï¼‰
- `PATCH /api/plans/:id` - æ›´æ–°è®¡åˆ’ï¼ˆéœ€è®¤è¯ï¼‰
- `DELETE /api/plans/:id` - åˆ é™¤è®¡åˆ’ï¼ˆéœ€è®¤è¯ï¼‰

## 6. é¡¹ç›®ç‰¹ç‚¹

1. **å®‰å…¨æ€§**: ä½¿ç”¨Argon2è¿›è¡Œå¯†ç å“ˆå¸Œï¼ŒJWTè¿›è¡Œèº«ä»½éªŒè¯
2. **CORSæ”¯æŒ**: æ”¯æŒè·¨åŸŸè¯·æ±‚ï¼Œä¾¿äºå‰ç«¯é›†æˆ
3. **é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œä½¿ç”¨è‡ªå®šä¹‰AppErroræšä¸¾
4. **æ•°æ®åº“è¿ç§»**: åŒ…å«æ•°æ®åº“ç»“æ„çš„è¿ç§»è„šæœ¬
5. **ç¯å¢ƒé…ç½®**: é€šè¿‡.envæ–‡ä»¶ç®¡ç†é…ç½®

## 7. é¡¹ç›®ç»“æ„

```
src/
â”œâ”€â”€ main.rs          # ä¸»ç¨‹åºå…¥å£ï¼Œè·¯ç”±é…ç½®ï¼ŒCORSè®¾ç½®
â”œâ”€â”€ models.rs        # æ•°æ®æ¨¡å‹å®šä¹‰
â”œâ”€â”€ handlers.rs      # APIå¤„ç†å‡½æ•°
â”œâ”€â”€ auth.rs          # è®¤è¯æ¨¡å—ï¼ˆJWTã€å¯†ç å“ˆå¸Œï¼‰
â””â”€â”€ error.rs         # é”™è¯¯å¤„ç†æ¨¡å—
```

## 8. æ•°æ®åº“è®¾è®¡

- ä½¿ç”¨PostgreSQLä½œä¸ºæ•°æ®åº“
- ç”¨æˆ·è¡¨å’Œè®¡åˆ’è¡¨é€šè¿‡å¤–é”®å…³è”
- è®¡åˆ’è¡¨æ”¯æŒè½¯åˆ é™¤çš„çº§è”åˆ é™¤ï¼ˆç”¨æˆ·åˆ é™¤æ—¶å…¶è®¡åˆ’ä¹Ÿä¼šè¢«åˆ é™¤ï¼‰
- ä¸ºæé«˜æŸ¥è¯¢æ•ˆç‡ï¼Œåœ¨user_idå­—æ®µä¸Šåˆ›å»ºäº†ç´¢å¼•

## 9. è®¤è¯æœºåˆ¶

- ä½¿ç”¨JWTä»¤ç‰Œè¿›è¡Œèº«ä»½éªŒè¯
- å®ç°äº†è‡ªå®šä¹‰çš„AuthUseræå–å™¨ï¼Œç¡®ä¿å—ä¿æŠ¤è·¯ç”±çš„å®‰å…¨æ€§
- ä»¤ç‰Œæœ‰æ•ˆæœŸä¸º24å°æ—¶
- é€šè¿‡ä¸­é—´ä»¶è‡ªåŠ¨éªŒè¯è¯·æ±‚ä¸­çš„Authorizationå¤´éƒ¨

## 10. è¿è¡Œé…ç½®

- æœåŠ¡å™¨è¿è¡Œåœ¨localhost:3000ç«¯å£
- æ”¯æŒé€šè¿‡ç¯å¢ƒå˜é‡é…ç½®æ•°æ®åº“è¿æ¥å’ŒJWTå¯†é’¥
- ä½¿ç”¨tracingè¿›è¡Œæ—¥å¿—è®°å½•å’Œè°ƒè¯•

è¿™ä¸ªé¡¹ç›®æ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€å®‰å…¨å¯é çš„è®¡åˆ’ç®¡ç†åç«¯ç³»ç»Ÿï¼Œå…·å¤‡äº†ç°ä»£Webåº”ç”¨æ‰€éœ€çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œé€‚åˆä¸å‰ç«¯åº”ç”¨é…åˆä½¿ç”¨ã€‚
### ç”¨æˆ·æ³¨å†Œ

```shell
curl -X POST http://localhost:3000/api/register \
  -H "Content-Type: application/json" \
  -d @register2.json
```
</file>

<file path="src/auth.rs">
// src/auth.rs
use argon2::{
    password_hash::{
        rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString
    },
    Argon2,
};
use serde::{Deserialize, Serialize};
use jsonwebtoken::{encode, decode, Header, Algorithm, Validation, EncodingKey, DecodingKey};
use chrono::{Utc, Duration};
use axum::{
    async_trait,
    extract::FromRequestParts,
    http::request::Parts,
    RequestPartsExt,
};
use axum_extra::{
    headers::{authorization::Bearer, Authorization},
    TypedHeader,
};
use crate::AppError; 
use uuid::Uuid;

// --- 1. å¯†ç å¤„ç† (Argon2) ---

pub fn hash_password(password: &str) -> Result<String, String> {
    let salt = SaltString::generate(&mut OsRng);
    let argon2 = Argon2::default();
    let password_hash = argon2.hash_password(password.as_bytes(), &salt)
        .map_err(|e| e.to_string())?
        .to_string();
    Ok(password_hash)
}

pub fn verify_password(password: &str, password_hash: &str) -> bool {
    let parsed_hash = match PasswordHash::new(password_hash) {
        Ok(h) => h,
        Err(_) => return false,
    };
    Argon2::default().verify_password(password.as_bytes(), &parsed_hash).is_ok()
}

// --- 2. JWT (Access Token) å¤„ç† ---

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: i32,         // ç”¨æˆ· ID
    pub username: String, 
    pub exp: usize,       // è¿‡æœŸæ—¶é—´
}

/// ç”ŸæˆçŸ­æ•ˆçš„ Access Token (ç”¨äº API è¯·æ±‚)
/// å»ºè®®æœ‰æ•ˆæœŸï¼š15 åˆ†é’Ÿ
pub fn create_jwt(user_id: i32, username: &str) -> Result<String, String> {
    let expiration = Utc::now()
        .checked_add_signed(Duration::seconds(30)) 
        .expect("valid timestamp")
        .timestamp();

    let claims = Claims {
        sub: user_id,
        username: username.to_owned(),
        exp: expiration as usize,
    };

    let secret = std::env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    
    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(secret.as_bytes()),
    )
    .map_err(|e| e.to_string())
}

// --- 3. Refresh Token å¤„ç† ---

/// ç”Ÿæˆå”¯ä¸€çš„éšæœºå­—ç¬¦ä¸²ä½œä¸ºåˆ·æ–°ä»¤ç‰Œ
pub fn generate_refresh_token() -> String {
    Uuid::new_v4().to_string()
}

// --- 4. æ ¸å¿ƒï¼šè®¤è¯æå–å™¨ (AuthUser Extractor) ---
// ç”¨äºåœ¨ Handler ä¸­é€šè¿‡ (user: AuthUser) è‡ªåŠ¨è·å–å½“å‰ç™»å½•ç”¨æˆ·

pub struct AuthUser {
    pub id: i32,
    #[allow(dead_code)] 
    pub username: String,
}

#[async_trait]
impl<S> FromRequestParts<S> for AuthUser
where
    S: Send + Sync,
{
    type Rejection = AppError;

    async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
        // 1. ä» HTTP Header æå– Bearer Token
        let TypedHeader(Authorization(bearer)) = parts
            .extract::<TypedHeader<Authorization<Bearer>>>()
            .await
            .map_err(|_| AppError::Auth("Token ç¼ºå¤±æˆ–æ ¼å¼é”™è¯¯".into()))?;

        // 2. éªŒè¯ Token æœ‰æ•ˆæ€§
        let secret = std::env::var("JWT_SECRET").unwrap_or_else(|_| "secret".into());
        let token_data = decode::<Claims>(
            bearer.token(),
            &DecodingKey::from_secret(secret.as_bytes()),
            &Validation::new(Algorithm::HS256),
        )
        .map_err(|e| {
            // å¦‚æœ Token è¿‡æœŸï¼Œjsonwebtoken ä¼šè¿”å›ç‰¹å®šé”™è¯¯ï¼Œå‰ç«¯æ‹¦æˆªå™¨ä¼šæ•è·å¹¶å¤„ç†
            tracing::warn!("JWT éªŒè¯å¤±è´¥: {}", e);
            AppError::Auth("Token å·²è¿‡æœŸæˆ–æ— æ•ˆ".into())
        })?;

        // 3. éªŒè¯é€šè¿‡ï¼Œæ„å»º AuthUser
        Ok(AuthUser {
            id: token_data.claims.sub,
            username: token_data.claims.username,
        })
    }
}
</file>

<file path="src/main.rs">
// src/main.rs
use axum::{
    http::Method,
    routing::{delete, get, patch, post},
    Router,
};
use sqlx::postgres::PgPoolOptions;
use sqlx::PgPool;
use std::net::SocketAddr;
use tower_http::cors::{Any, CorsLayer};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod auth;
mod error;
mod handlers;
mod models;
mod validation;

pub use error::AppError;

use handlers::*;

#[derive(Clone)]
pub struct AppState {
    pub db: PgPool,
}

#[tokio::main]
async fn main() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "debug".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    dotenvy::dotenv().ok();
    let db_url = std::env::var("DATABASE_URL").expect("DATABASE_URL must be set in .env");

    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&db_url)
        .await
        .expect("Failed to connect to Postgres");

    tracing::info!("âœ… æ•°æ®åº“è¿æ¥æˆåŠŸ!");

    let state = AppState { db: pool };

    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods([Method::GET, Method::POST, Method::PATCH, Method::DELETE])
        .allow_headers(Any);

    let app = Router::new()
        // è®¤è¯
        .route("/api/register", post(register_handler))
        .route("/api/login", post(login_handler))
        .route("/api/refresh", post(refresh_handler))
        // é¡¹ç›®è·¯ç”±
        .route("/api/projects", get(get_projects_handler))
        .route("/api/projects", post(create_project_handler))
        .route("/api/projects/:id", patch(update_project_handler))
        .route("/api/projects/:id", delete(delete_project_handler))
        // ä»»åŠ¡è·¯ç”±
        .route("/api/issues", get(get_all_my_issues_handler))
        .route("/api/projects/:id/issues", get(get_project_issues_handler)) // è·å–é¡¹ç›®ä¸‹çš„ Issue
        .route("/api/issues", post(create_issue_handler))
        .route("/api/issues/:id", patch(update_issue_handler))
        .route("/api/issues/:id", delete(delete_issue_handler))
        .with_state(state)
        .layer(cors);

    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    tracing::info!("ğŸš€ æœåŠ¡å™¨è¿è¡Œåœ¨: {}", addr);

    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}
</file>

<file path="src/error.rs">
// src/error.rs
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;
use thiserror::Error;
use validator::ValidationErrors;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("Database error")]
    Database(#[from] sqlx::Error),

    #[error("Authentication failed: {0}")]
    Auth(String),

    #[error("Not found")]
    NotFound(String),

    // --- æ–°å¢ï¼šå¤„ç†æƒé™ä¸è¶³ (403) ---
    #[error("Forbidden: {0}")]
    Forbidden(String),

    #[error("Internal server error")]
    Internal,

    #[error("Validation error")]
    ValidationError(#[from] ValidationErrors),

    #[error("Bad request: {0}")]
    BadRequest(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, message, details) = match self {
            AppError::Database(ref e) => {
                tracing::error!("DB Error: {:?}", e);
                if e.to_string().contains("duplicate key") {
                    (StatusCode::CONFLICT, "è®°å½•å·²å­˜åœ¨".to_string(), None)
                } else {
                    (
                        StatusCode::INTERNAL_SERVER_ERROR,
                        "æ•°æ®åº“æ“ä½œå¤±è´¥".to_string(),
                        None,
                    )
                }
            }
            AppError::Auth(msg) => (StatusCode::UNAUTHORIZED, msg, None),
            AppError::NotFound(msg) => (StatusCode::NOT_FOUND, msg, None),
            
            // --- æ˜ å°„ Forbidden åˆ° 403 ---
            AppError::Forbidden(msg) => (StatusCode::FORBIDDEN, msg, None),

            AppError::ValidationError(e) => {
                let mut errors = std::collections::HashMap::new();
                for (field, field_errors) in e.field_errors() {
                    let msgs: Vec<String> = field_errors
                        .iter()
                        .map(|fe| {
                            fe.message
                                .as_ref()
                                .map(|m| m.to_string())
                                .unwrap_or_else(|| "æ ¼å¼ä¸æ­£ç¡®".to_string())
                        })
                        .collect();
                    errors.insert(field, msgs);
                }
                (
                    StatusCode::BAD_REQUEST,
                    "è¾“å…¥æ ¡éªŒå¤±è´¥".to_string(),
                    Some(json!(errors)),
                )
            }
            AppError::BadRequest(msg) => (StatusCode::BAD_REQUEST, msg, None),
            AppError::Internal => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "æœåŠ¡å™¨å†…éƒ¨é”™è¯¯".to_string(),
                None,
            ),
        };

        let body = Json(json!({
            "status": "error",
            "message": message,
            "errors": details
        }));

        (status, body).into_response()
    }
}
</file>

<file path="src/handlers.rs">
// src/handlers.rs
use crate::auth::{create_jwt, hash_password, verify_password, AuthUser, generate_refresh_token};
use crate::models::*;
use crate::AppError;
use crate::AppState;
use crate::validation::ValidatedJson;
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    Json,
};
use serde_json::json;
use chrono::{Utc, Duration};

// ======= PROJECTS HANDLERS =======

pub async fn get_projects_handler(
    user: AuthUser,
    State(state): State<AppState>,
) -> Result<Json<Vec<Project>>, AppError> {
    let projects = sqlx::query_as::<_, Project>(
        "SELECT * FROM projects WHERE user_id = $1 ORDER BY updated_at DESC",
    )
    .bind(user.id)
    .fetch_all(&state.db)
    .await?;
    Ok(Json(projects))
}

pub async fn create_project_handler(
    user: AuthUser,
    State(state): State<AppState>,
    ValidatedJson(body): ValidatedJson<CreateProjectSchema>,
) -> Result<Json<Project>, AppError> {
    let project = sqlx::query_as::<_, Project>(
        "INSERT INTO projects (user_id, name, description, color) VALUES ($1, $2, $3, $4) RETURNING *",
    )
    .bind(user.id)
    .bind(body.name)
    .bind(body.description)
    .bind(body.color.unwrap_or_else(|| "#5E6AD2".to_string()))
    .fetch_one(&state.db)
    .await?;
    Ok(Json(project))
}

pub async fn update_project_handler(
    user: AuthUser,
    Path(id): Path<i32>,
    State(state): State<AppState>,
    ValidatedJson(body): ValidatedJson<UpdateProjectSchema>,
) -> Result<Json<Project>, AppError> {
    let project = sqlx::query_as::<_, Project>(
        r#"UPDATE projects SET 
            name = COALESCE($1, name),
            description = COALESCE($2, description),
            status = COALESCE($3, status),
            color = COALESCE($4, color),
            updated_at = NOW()
         WHERE id = $5 AND user_id = $6
         RETURNING *"#,
    )
    .bind(body.name).bind(body.description).bind(body.status).bind(body.color)
    .bind(id).bind(user.id)
    .fetch_optional(&state.db)
    .await?
    .ok_or_else(|| AppError::NotFound("é¡¹ç›®æœªæ‰¾åˆ°".into()))?;

    Ok(Json(project))
}

pub async fn delete_project_handler(
    user: AuthUser,
    Path(id): Path<i32>,
    State(state): State<AppState>,
) -> Result<StatusCode, AppError> {
    let res = sqlx::query("DELETE FROM projects WHERE id = $1 AND user_id = $2")
        .bind(id)
        .bind(user.id)
        .execute(&state.db)
        .await?;
    if res.rows_affected() == 0 { return Err(AppError::NotFound("é¡¹ç›®ä¸å­˜åœ¨æˆ–æ— æƒæ“ä½œ".into())); }
    Ok(StatusCode::NO_CONTENT)
}

// ======= ISSUES HANDLERS =======

pub async fn get_all_my_issues_handler(
    user: AuthUser,
    State(state): State<AppState>,
) -> Result<Json<Vec<Issue>>, AppError> {
    let issues = sqlx::query_as::<_, Issue>(
        "SELECT * FROM issues WHERE user_id = $1 ORDER BY updated_at DESC",
    )
    .bind(user.id)
    .fetch_all(&state.db)
    .await?;

    Ok(Json(issues))
}

pub async fn get_project_issues_handler(
    user: AuthUser,
    Path(project_id): Path<i32>,
    Query(query): Query<IssueQuery>,
    State(state): State<AppState>,
) -> Result<Json<Vec<Issue>>, AppError> {
    let project_exists = sqlx::query("SELECT id FROM projects WHERE id = $1 AND user_id = $2")
        .bind(project_id)
        .bind(user.id)
        .fetch_optional(&state.db)
        .await?;

    if project_exists.is_none() { return Err(AppError::Forbidden("æ— æƒè®¿é—®è¯¥é¡¹ç›®".into())); }

    let issues = sqlx::query_as::<_, Issue>(
        r#"
        SELECT * FROM issues 
        WHERE project_id = $1 
          AND ($2 IS NULL OR title ILIKE $2 OR description ILIKE $2)
          AND ($3 IS NULL OR status = $3)
        ORDER BY priority DESC, created_at DESC
        "#,
    )
    .bind(project_id)
    .bind(query.q.map(|s| format!("%{}%", s)))
    .bind(query.status)
    .fetch_all(&state.db)
    .await?;

    Ok(Json(issues))
}

pub async fn create_issue_handler(
    user: AuthUser,
    State(state): State<AppState>,
    ValidatedJson(body): ValidatedJson<CreateIssueSchema>,
) -> Result<Json<Issue>, AppError> {
    let project_owned = sqlx::query("SELECT id FROM projects WHERE id = $1 AND user_id = $2")
        .bind(body.project_id)
        .bind(user.id)
        .fetch_optional(&state.db)
        .await?;

    if project_owned.is_none() { return Err(AppError::BadRequest("ç›®æ ‡é¡¹ç›®ä¸å­˜åœ¨".into())); }

    let issue = sqlx::query_as::<_, Issue>(
        r#"INSERT INTO issues (project_id, user_id, title, description, priority, due_date) 
           VALUES ($1, $2, $3, $4, $5, $6) RETURNING *"#,
    )
    .bind(body.project_id)
    .bind(user.id)
    .bind(body.title)
    .bind(body.description)
    .bind(body.priority.unwrap_or(0))
    .bind(body.due_date)
    .fetch_one(&state.db)
    .await?;

    Ok(Json(issue))
}

pub async fn update_issue_handler(
    user: AuthUser,
    Path(id): Path<i32>,
    State(state): State<AppState>,
    ValidatedJson(body): ValidatedJson<UpdateIssueSchema>,
) -> Result<Json<Issue>, AppError> {
    let issue = sqlx::query_as::<_, Issue>(
        r#"UPDATE issues SET 
            title = COALESCE($1, title),
            description = CASE WHEN $2 IS NULL THEN description ELSE $2 END,
            status = COALESCE($3, status),
            priority = COALESCE($4, priority),
            due_date = COALESCE($5, due_date),
            updated_at = NOW()
         WHERE id = $6 AND user_id = $7
         RETURNING *"#,
    )
    .bind(body.title).bind(body.description).bind(body.status).bind(body.priority).bind(body.due_date)
    .bind(id).bind(user.id)
    .fetch_optional(&state.db)
    .await?
    .ok_or_else(|| AppError::NotFound("ä»»åŠ¡æœªæ‰¾åˆ°".into()))?;

    Ok(Json(issue))
}

pub async fn delete_issue_handler(
    user: AuthUser,
    Path(id): Path<i32>,
    State(state): State<AppState>,
) -> Result<StatusCode, AppError> {
    let res = sqlx::query("DELETE FROM issues WHERE id = $1 AND user_id = $2")
        .bind(id).bind(user.id).execute(&state.db).await?;
    if res.rows_affected() == 0 { return Err(AppError::NotFound("ä»»åŠ¡æœªæ‰¾åˆ°".into())); }
    Ok(StatusCode::NO_CONTENT)
}

// ======= AUTH HANDLERS (æ— æ„Ÿåˆ·æ–°ç‰ˆæœ¬) =======

pub async fn register_handler(
    State(state): State<AppState>,
    ValidatedJson(payload): ValidatedJson<RegisterSchema>,
) -> Result<Json<serde_json::Value>, AppError> {
    let hashed_password = hash_password(&payload.password).map_err(|_| AppError::Internal)?;
    sqlx::query("INSERT INTO users (username, password_hash) VALUES ($1, $2)")
        .bind(&payload.username).bind(hashed_password).execute(&state.db).await?;
    Ok(Json(json!({"message": "User registered successfully"})))
}

pub async fn login_handler(
    State(state): State<AppState>,
    ValidatedJson(payload): ValidatedJson<LoginSchema>,
) -> Result<Json<AuthResponse>, AppError> {
    // 1. éªŒè¯ç”¨æˆ·
    let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE username = $1")
        .bind(&payload.username).fetch_optional(&state.db).await?
        .ok_or_else(|| AppError::Auth("ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯".into()))?;

    if !verify_password(&payload.password, &user.password_hash) {
        return Err(AppError::Auth("ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯".into()));
    }

    // 2. ç”Ÿæˆ Access Token (çŸ­æ•ˆ)
    let token = create_jwt(user.id, &user.username).map_err(|_| AppError::Internal)?;

    // 3. ç”Ÿæˆå¹¶å­˜å‚¨ Refresh Token (é•¿æ•ˆ)
    let refresh_token_str = generate_refresh_token();
    let expires_at = Utc::now() + Duration::days(7); // 7å¤©æœ‰æ•ˆæœŸ

    sqlx::query(
        "INSERT INTO refresh_tokens (user_id, token, expires_at) VALUES ($1, $2, $3)"
    )
    .bind(user.id)
    .bind(&refresh_token_str)
    .bind(expires_at)
    .execute(&state.db)
    .await?;

    Ok(Json(AuthResponse { 
        token, 
        refresh_token: Some(refresh_token_str),
        username: user.username 
    }))
}

// æ ¸å¿ƒï¼šæ— æ„Ÿåˆ·æ–°æ¥å£
pub async fn refresh_handler(
    State(state): State<AppState>,
    Json(payload): Json<RefreshRequest>,
) -> Result<Json<AuthResponse>, AppError> {
    // 1. æ£€æŸ¥æ•°æ®åº“ä¸­æ˜¯å¦å­˜åœ¨è¯¥ Token ä¸”æœªè¿‡æœŸ
    let row = sqlx::query!(
        r#"SELECT r.user_id, u.username FROM refresh_tokens r
           JOIN users u ON r.user_id = u.id
           WHERE r.token = $1 AND r.expires_at > NOW()"#,
        payload.refresh_token
    )
    .fetch_optional(&state.db)
    .await?
    .ok_or_else(|| AppError::Auth("ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•".into()))?;

    // 2. ç­¾å‘æ–°çš„ Access Token
    let new_access_token = create_jwt(row.user_id, &row.username).map_err(|_| AppError::Internal)?;

    // 3. è¿”å›æ–° Token (è¿™é‡Œæ²¿ç”¨æ—§çš„ Refresh Tokenï¼Œä¹Ÿå¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œæ»šåŠ¨æ›´æ–°)
    Ok(Json(AuthResponse {
        token: new_access_token,
        refresh_token: Some(payload.refresh_token),
        username: row.username,
    }))
}
</file>

<file path="src/models.rs">
// src/models.rs
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::FromRow;
use validator::Validate;

// --- 1. Project æ¨¡å‹ ---
#[derive(Debug, FromRow, Serialize)]
pub struct Project {
    pub id: i32,
    pub user_id: i32,
    pub name: String,
    pub description: Option<String>,
    pub status: String,
    pub color: Option<String>,
    pub created_at: Option<DateTime<Utc>>,
    pub updated_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Deserialize, Validate)]
pub struct CreateProjectSchema {
    #[validate(length(min = 1, max = 100, message = "é¡¹ç›®åç§°ä¸èƒ½ä¸ºç©º"))]
    pub name: String,
    pub description: Option<String>,
    pub color: Option<String>,
}

#[derive(Debug, Deserialize, Validate)]
pub struct UpdateProjectSchema {
    pub name: Option<String>,
    pub description: Option<String>,
    pub status: Option<String>,
    pub color: Option<String>,
}

// --- 2. Issue æ¨¡å‹ (ç”±åŸ Plan å‡çº§) ---
#[derive(Debug, FromRow, Serialize)]
pub struct Issue {
    pub id: i32,
    pub project_id: i32,
    pub user_id: i32,
    pub title: String,
    pub description: Option<String>,
    pub status: String,
    pub priority: i32,
    pub due_date: Option<DateTime<Utc>>,
    pub created_at: Option<DateTime<Utc>>,
    pub updated_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Deserialize, Validate)]
pub struct CreateIssueSchema {
    pub project_id: i32, // å¿…é¡»æŒ‡å®šæ‰€å±é¡¹ç›®
    #[validate(length(min = 1, max = 255, message = "æ ‡é¢˜ä¸èƒ½ä¸ºç©º"))]
    pub title: String,
    #[validate(length(min = 5, message = "æè¿°å†…å®¹è‡³å°‘éœ€è¦ 5 ä¸ªå­—"))]
    pub description: Option<String>,
    pub priority: Option<i32>,
    pub due_date: Option<DateTime<Utc>>,
}

#[derive(Debug, Deserialize, Validate)]
pub struct UpdateIssueSchema {
    #[validate(length(min = 1, max = 255, message = "æ ‡é¢˜ä¸èƒ½ä¸ºç©º"))]
    pub title: Option<String>,
    // #[validate(length(min = 5, message = "æè¿°å†…å®¹è‡³å°‘éœ€è¦ 5 ä¸ªå­—"))]
    pub description: Option<String>,
    pub status: Option<String>,
    pub priority: Option<i32>,
    pub due_date: Option<DateTime<Utc>>,
}

// --- 3. è®¤è¯ä¸æŸ¥è¯¢æ¨¡å‹ ---
#[derive(Debug, FromRow, Deserialize, Serialize)]
pub struct User {
    pub id: i32,
    pub username: String,
    #[serde(skip)]
    pub password_hash: String,
    pub created_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Deserialize, Validate)]
pub struct RegisterSchema {
    #[validate(length(min = 3, max = 20, message = "ç”¨æˆ·åé•¿åº¦éœ€åœ¨ 3-20 ä½ä¹‹é—´"))]
    pub username: String,
    #[validate(length(min = 6, message = "å¯†ç è‡³å°‘éœ€è¦ 6 ä½"))]
    pub password: String,
}

#[derive(Debug, Deserialize, Validate)]
pub struct LoginSchema {
    pub username: String,
    pub password: String,
}

#[derive(Debug, Serialize)]
pub struct AuthResponse {
    pub token: String,
    pub refresh_token: Option<String>,
    pub username: String,
}

#[derive(Debug, Deserialize)]
pub struct IssueQuery {
    pub q: Option<String>,
    pub status: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct RefreshRequest {
    pub refresh_token: String,
}
</file>

</files>
