This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env_template
.gitignore
Cargo.toml
data.json
migrations/20251230160043_init_schema.down.sql
migrations/20251230160043_init_schema.up.sql
README.md
register.json
register2.json
src/auth.rs
src/error.rs
src/handlers.rs
src/main.rs
src/models.rs
src/validation.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env_template">
# æ•°æ®åº“è¿æ¥ URL
DATABASE_URL=postgres://ç”¨æˆ·å:å¯†ç @åœ°å€:ç«¯å£/æ•°æ®åº“å
# æ—¥å¿—çº§åˆ«
RUST_LOG=debug
# JWT å¯†é’¥
JWT_SECRET=xxxxxxxxxxxxxxxxxxxxxxxxxxx
</file>

<file path="data.json">
{
  "title": "å­¦ä¹  Rust",
  "description": "å®Œæˆ CRUD æ¥å£å¼€å‘",
  "category": "work"
}
</file>

<file path="migrations/20251230160043_init_schema.down.sql">
-- Add down migration script here
DROP TABLE IF EXISTS plans;
DROP TABLE IF EXISTS users;
</file>

<file path="register.json">
{ "username": "admin", "password": "mypassword123" }
</file>

<file path=".gitignore">
/target
.env
</file>

<file path="migrations/20251230160043_init_schema.up.sql">
-- Add up migration script here
CREATE TABLE users (
    id SERIAL PRIMARY KEY,                     -- è‡ªå¢ä¸»é”®
    username VARCHAR(50) NOT NULL UNIQUE,      -- ç”¨æˆ·åï¼Œå¿…é¡»å”¯ä¸€
    password_hash VARCHAR(255) NOT NULL,       -- å¯†ç å“ˆå¸Œ (ä¸¥ç¦æ˜æ–‡å­˜å‚¨ï¼Œæ¨è Argon2)
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP -- åˆ›å»ºæ—¶é—´
);

CREATE TABLE plans (
    id SERIAL PRIMARY KEY,

    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE, -- å…³è”ç”¨æˆ·

    -- æ ¸å¿ƒå†…å®¹
    title VARCHAR(150) NOT NULL,               -- è®¡åˆ’æ ‡é¢˜
    description TEXT,                          -- è¯¦ç»†æè¿° (æ”¯æŒ Markdown æ›´å¥½)
    
    -- çŠ¶æ€ç®¡ç† (å»ºè®®å‰ç«¯åšæšä¸¾æ˜ å°„)
    -- values: 'pending'(å¾…åŠ), 'in_progress'(è¿›è¡Œä¸­), 'completed'(å·²å®Œæˆ), 'archived'(å½’æ¡£)
    status VARCHAR(20) NOT NULL DEFAULT 'pending', 
    
    -- åˆ†ç±»ä¸ä¼˜å…ˆçº§
    category VARCHAR(50) DEFAULT 'life',       -- ä¾‹å¦‚: 'work', 'life', 'study'
    priority INTEGER DEFAULT 0,                -- ä¼˜å…ˆçº§: 0(æ™®é€š), 1(é‡è¦), 2(ç´§æ€¥)
    
    -- æ—¶é—´ç®¡ç†
    due_date TIMESTAMP WITH TIME ZONE,         -- æˆªæ­¢æ—¥æœŸ (å¯ä¸ºç©º)
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    -- æƒé™æ§åˆ¶
    -- å¦‚æœæ˜¯ falseï¼Œåªæœ‰ç™»å½•åå¯è§ï¼›å¦‚æœæ˜¯ trueï¼Œæ¸¸å®¢å¯è§
    is_public BOOLEAN NOT NULL DEFAULT TRUE    
);
-- å»ºè®®æ·»åŠ ç´¢å¼•ä»¥æé«˜æŸ¥è¯¢æ•ˆç‡
CREATE INDEX idx_plans_user_id ON plans(user_id);
</file>

<file path="register2.json">
{ "username": "brace3", "password": "myp" }
</file>

<file path="src/validation.rs">
// src/validation.rs
use axum::{
    async_trait,
    extract::{FromRequest, Request}, // ä¿®æ­£ä¸º Request
    Json,
};
use validator::Validate;
use crate::AppError;

pub struct ValidatedJson<T>(pub T);

#[async_trait]
impl<S, T> FromRequest<S> for ValidatedJson<T>
where
    S: Send + Sync,
    T: Validate + serde::de::DeserializeOwned + 'static, // å¢åŠ  'static çº¦æŸ
{
    type Rejection = AppError;

    async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
        // 1. åˆ©ç”¨ Axum åŸç”Ÿçš„ Json æå–å™¨è§£æ Body
        // å¦‚æœ JSON æ ¼å¼éæ³•ï¼ˆæ¯”å¦‚å°‘æ‹¬å·ï¼‰ï¼Œè¿™é‡Œä¼šç›´æ¥è¿”å› BadRequest
        let Json(value) = Json::<T>::from_request(req, state).await
            .map_err(|rejection| AppError::BadRequest(rejection.body_text()))?;
        
        // 2. æ‰§è¡Œ validator çš„æ ¡éªŒé€»è¾‘
        // å¦‚æœæ ¡éªŒå¤±è´¥ï¼ˆæ¯”å¦‚æ ‡é¢˜å¤ªçŸ­ï¼‰ï¼Œä¼šé€šè¿‡ AppError::ValidationError è‡ªåŠ¨è½¬æ¢
        value.validate()?; 
        
        Ok(ValidatedJson(value))
    }
}
</file>

<file path="Cargo.toml">
[package]
name = "my-life-planner"
version = "0.1.0"
edition = "2021"

[dependencies]
# Web æ¡†æ¶
axum = "0.7"

# å¼‚æ­¥è¿è¡Œæ—¶ (Rust çš„å¼‚æ­¥å¼•æ“)
tokio = { version = "1", features = ["full"] }

# æ•°æ®åº“é©±åŠ¨ (PostgreSQL)
# runtime-tokio: æŒ‡å®šå¼‚æ­¥è¿è¡Œæ—¶
# tls-native-tls: å¤„ç†æ•°æ®åº“è¿æ¥çš„åŠ å¯†
sqlx = { version = "0.7", features = ["runtime-tokio", "tls-native-tls", "postgres", "chrono", "uuid"] }

# åºåˆ—åŒ–/ååºåˆ—åŒ– (JSONå¤„ç†)
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# ç¯å¢ƒå˜é‡è¯»å–
dotenvy = "0.15"

#å¤„ç†æ•°æ®åº“ä¸­çš„æ—¶é—´å­—æ®µ
chrono = { version = "0.4", features = ["serde"] }

# æ—¥å¿—è¿½è¸ª
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

argon2 = "0.5"
rand_core = { version = "0.6", features = ["std"] }
jsonwebtoken = "9"
axum-extra = { version = "0.9", features = ["typed-header"] }
headers = "0.4"

tower-http = { version = "0.5", features = ["cors"] }

thiserror = "1.0"

validator = { version = "0.19", features = ["derive"] }
</file>

<file path="README.md">
# My-Life-Planner é¡¹ç›®ç³»ç»Ÿæ¢³ç†ä¸æ€»ç»“

æ ¹æ®å¯¹é¡¹ç›®çš„å…¨é¢åˆ†æï¼Œä»¥ä¸‹æ˜¯"My-Life-Planner"ï¼ˆæˆ‘çš„ç”Ÿæ´»è®¡åˆ’å™¨ï¼‰é¡¹ç›®çš„ç³»ç»Ÿæ¢³ç†ä¸æ€»ç»“ï¼š

## 1. é¡¹ç›®æ¦‚è¿°

è¿™æ˜¯ä¸€ä¸ªåŸºäºRustå’ŒAxumæ¡†æ¶å¼€å‘çš„ç”Ÿæ´»è®¡åˆ’ç®¡ç†åç«¯ç³»ç»Ÿï¼Œæ—¨åœ¨å¸®åŠ©ç”¨æˆ·ç®¡ç†ä¸ªäººè®¡åˆ’å’Œä»»åŠ¡ã€‚é¡¹ç›®é‡‡ç”¨ç°ä»£åŒ–çš„WebæŠ€æœ¯æ ˆï¼Œæä¾›äº†å®Œæ•´çš„ç”¨æˆ·è®¤è¯å’Œè®¡åˆ’ç®¡ç†åŠŸèƒ½ã€‚

## 2. æŠ€æœ¯æ ˆ

- **Webæ¡†æ¶**: Axum (Rust)
- **å¼‚æ­¥è¿è¡Œæ—¶**: Tokio
- **æ•°æ®åº“**: PostgreSQL (é€šè¿‡SQLx)
- **æ•°æ®åºåˆ—åŒ–**: Serde/serde_json
- **å¯†ç å“ˆå¸Œ**: Argon2
- **JWTè®¤è¯**: jsonwebtoken
- **æ—¥å¿—è¿½è¸ª**: tracing
- **CORSæ”¯æŒ**: tower-http

## 3. æ ¸å¿ƒåŠŸèƒ½

### 3.1 ç”¨æˆ·ç³»ç»Ÿ
- **ç”¨æˆ·æ³¨å†Œ**: åˆ›å»ºæ–°ç”¨æˆ·è´¦å·ï¼Œå¯†ç ä½¿ç”¨Argon2åŠ å¯†å­˜å‚¨
- **ç”¨æˆ·ç™»å½•**: éªŒè¯ç”¨æˆ·èº«ä»½å¹¶ç”ŸæˆJWTä»¤ç‰Œ

### 3.2 è®¡åˆ’ç®¡ç†
- **åˆ›å»ºè®¡åˆ’**: ç”¨æˆ·å¯ä»¥åˆ›å»ºæ–°çš„è®¡åˆ’/ä»»åŠ¡
- **è·å–è®¡åˆ’**: å¯ä»¥è·å–å…¬å¼€çš„è®¡åˆ’åˆ—è¡¨
- **æ›´æ–°è®¡åˆ’**: ä¿®æ”¹å·²æœ‰çš„è®¡åˆ’ä¿¡æ¯
- **åˆ é™¤è®¡åˆ’**: åˆ é™¤æŒ‡å®šçš„è®¡åˆ’

### 3.3 æƒé™æ§åˆ¶
- **å…¬å¼€/ç§æœ‰**: è®¡åˆ’å¯ä»¥è®¾ç½®ä¸ºå…¬å¼€æˆ–ç§æœ‰
- **èº«ä»½éªŒè¯**: å—ä¿æŠ¤çš„APIç«¯ç‚¹éœ€è¦æœ‰æ•ˆçš„JWTä»¤ç‰Œ

## 4. æ•°æ®æ¨¡å‹

### ç”¨æˆ·è¡¨ (users)
- ID (ä¸»é”®ï¼Œè‡ªå¢)
- ç”¨æˆ·å (å”¯ä¸€)
- å¯†ç å“ˆå¸Œ (ä½¿ç”¨Argon2åŠ å¯†)
- åˆ›å»ºæ—¶é—´

### è®¡åˆ’è¡¨ (plans)
- ID (ä¸»é”®ï¼Œè‡ªå¢)
- ç”¨æˆ·ID (å¤–é”®ï¼Œå…³è”ç”¨æˆ·è¡¨)
- æ ‡é¢˜
- æè¿°
- çŠ¶æ€ (å¾…åŠã€è¿›è¡Œä¸­ã€å·²å®Œæˆã€å½’æ¡£)
- åˆ†ç±» (å·¥ä½œã€ç”Ÿæ´»ã€å­¦ä¹ ç­‰)
- ä¼˜å…ˆçº§
- æˆªæ­¢æ—¥æœŸ
- å…¬å¼€æ€§ (å…¬å¼€/ç§æœ‰)
- åˆ›å»ºå’Œæ›´æ–°æ—¶é—´

## 5. APIç«¯ç‚¹

- `GET /api/plans` - è·å–å…¬å¼€è®¡åˆ’åˆ—è¡¨ï¼ˆå¯é€‰è®¤è¯ï¼Œç™»å½•åå¯çœ‹åˆ°è‡ªå·±çš„ç§æœ‰è®¡åˆ’ï¼‰
- `POST /api/register` - ç”¨æˆ·æ³¨å†Œ
- `POST /api/login` - ç”¨æˆ·ç™»å½•
- `POST /api/plans` - åˆ›å»ºæ–°è®¡åˆ’ï¼ˆéœ€è®¤è¯ï¼‰
- `PATCH /api/plans/:id` - æ›´æ–°è®¡åˆ’ï¼ˆéœ€è®¤è¯ï¼‰
- `DELETE /api/plans/:id` - åˆ é™¤è®¡åˆ’ï¼ˆéœ€è®¤è¯ï¼‰

## 6. é¡¹ç›®ç‰¹ç‚¹

1. **å®‰å…¨æ€§**: ä½¿ç”¨Argon2è¿›è¡Œå¯†ç å“ˆå¸Œï¼ŒJWTè¿›è¡Œèº«ä»½éªŒè¯
2. **CORSæ”¯æŒ**: æ”¯æŒè·¨åŸŸè¯·æ±‚ï¼Œä¾¿äºå‰ç«¯é›†æˆ
3. **é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œä½¿ç”¨è‡ªå®šä¹‰AppErroræšä¸¾
4. **æ•°æ®åº“è¿ç§»**: åŒ…å«æ•°æ®åº“ç»“æ„çš„è¿ç§»è„šæœ¬
5. **ç¯å¢ƒé…ç½®**: é€šè¿‡.envæ–‡ä»¶ç®¡ç†é…ç½®

## 7. é¡¹ç›®ç»“æ„

```
src/
â”œâ”€â”€ main.rs          # ä¸»ç¨‹åºå…¥å£ï¼Œè·¯ç”±é…ç½®ï¼ŒCORSè®¾ç½®
â”œâ”€â”€ models.rs        # æ•°æ®æ¨¡å‹å®šä¹‰
â”œâ”€â”€ handlers.rs      # APIå¤„ç†å‡½æ•°
â”œâ”€â”€ auth.rs          # è®¤è¯æ¨¡å—ï¼ˆJWTã€å¯†ç å“ˆå¸Œï¼‰
â””â”€â”€ error.rs         # é”™è¯¯å¤„ç†æ¨¡å—
```

## 8. æ•°æ®åº“è®¾è®¡

- ä½¿ç”¨PostgreSQLä½œä¸ºæ•°æ®åº“
- ç”¨æˆ·è¡¨å’Œè®¡åˆ’è¡¨é€šè¿‡å¤–é”®å…³è”
- è®¡åˆ’è¡¨æ”¯æŒè½¯åˆ é™¤çš„çº§è”åˆ é™¤ï¼ˆç”¨æˆ·åˆ é™¤æ—¶å…¶è®¡åˆ’ä¹Ÿä¼šè¢«åˆ é™¤ï¼‰
- ä¸ºæé«˜æŸ¥è¯¢æ•ˆç‡ï¼Œåœ¨user_idå­—æ®µä¸Šåˆ›å»ºäº†ç´¢å¼•

## 9. è®¤è¯æœºåˆ¶

- ä½¿ç”¨JWTä»¤ç‰Œè¿›è¡Œèº«ä»½éªŒè¯
- å®ç°äº†è‡ªå®šä¹‰çš„AuthUseræå–å™¨ï¼Œç¡®ä¿å—ä¿æŠ¤è·¯ç”±çš„å®‰å…¨æ€§
- ä»¤ç‰Œæœ‰æ•ˆæœŸä¸º24å°æ—¶
- é€šè¿‡ä¸­é—´ä»¶è‡ªåŠ¨éªŒè¯è¯·æ±‚ä¸­çš„Authorizationå¤´éƒ¨

## 10. è¿è¡Œé…ç½®

- æœåŠ¡å™¨è¿è¡Œåœ¨localhost:3000ç«¯å£
- æ”¯æŒé€šè¿‡ç¯å¢ƒå˜é‡é…ç½®æ•°æ®åº“è¿æ¥å’ŒJWTå¯†é’¥
- ä½¿ç”¨tracingè¿›è¡Œæ—¥å¿—è®°å½•å’Œè°ƒè¯•

è¿™ä¸ªé¡¹ç›®æ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€å®‰å…¨å¯é çš„è®¡åˆ’ç®¡ç†åç«¯ç³»ç»Ÿï¼Œå…·å¤‡äº†ç°ä»£Webåº”ç”¨æ‰€éœ€çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œé€‚åˆä¸å‰ç«¯åº”ç”¨é…åˆä½¿ç”¨ã€‚
### ç”¨æˆ·æ³¨å†Œ

```shell
curl -X POST http://localhost:3000/api/register \
  -H "Content-Type: application/json" \
  -d @register2.json
```
</file>

<file path="src/auth.rs">
// src/auth.rs
use argon2::{
    password_hash::{
        rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString
    },
    Argon2,
};
use serde::{Deserialize, Serialize};
use jsonwebtoken::{encode, decode, Header, Algorithm, Validation, EncodingKey, DecodingKey};
use chrono::{Utc, Duration};
use axum::{
    async_trait,
    extract::FromRequestParts,
    http::{request::Parts, StatusCode},
    response::{IntoResponse, Response},
    Json, RequestPartsExt,
};
use axum_extra::{
    headers::{authorization::Bearer, Authorization},
    TypedHeader,
};
use serde_json::json;
use crate::AppError; // å¼•å…¥è‡ªå®šä¹‰é”™è¯¯
// --- 1. å¯†ç å¤„ç† ---

// åŠ å¯†å¯†ç 
pub fn hash_password(password: &str) -> Result<String, String> {
    let salt = SaltString::generate(&mut OsRng);
    let argon2 = Argon2::default();
    let password_hash = argon2.hash_password(password.as_bytes(), &salt)
        .map_err(|e| e.to_string())?
        .to_string();
    Ok(password_hash)
}

// éªŒè¯å¯†ç 
pub fn verify_password(password: &str, password_hash: &str) -> bool {
    let parsed_hash = match PasswordHash::new(password_hash) {
        Ok(h) => h,
        Err(_) => return false,
    };
    Argon2::default().verify_password(password.as_bytes(), &parsed_hash).is_ok()
}

// --- 2. JWT å¤„ç† ---

// Token é‡Œçš„æ•°æ®ç»“æ„ (Claims)
#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: i32,    // å°† sub æ”¹ä¸ºç”¨æˆ· ID (i32)
    pub username: String, // ä¿ç•™ç”¨æˆ·åç”¨äºæ˜¾ç¤º
    pub exp: usize,
}

// åˆ›å»º Token
pub fn create_jwt(user_id: i32, username: &str) -> Result<String, String> {
    let expiration = Utc::now()
        .checked_add_signed(Duration::hours(24)) // Token 24å°æ—¶æœ‰æ•ˆ
        .expect("valid timestamp")
        .timestamp();

    let claims = Claims {
        sub: user_id,
        username: username.to_owned(),
        exp: expiration as usize,
    };

    let secret = std::env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    
    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(secret.as_bytes()),
    )
    .map_err(|e| e.to_string())
}

// --- 3. æ ¸å¿ƒï¼šè®¤è¯æå–å™¨ (Extractor) ---
// è¿™æ˜¯ä¸€ä¸ªâ€œå®ˆé—¨å‘˜â€ã€‚ä»»ä½•åœ¨å‚æ•°é‡Œå†™äº† AuthUser çš„æ¥å£ï¼Œéƒ½ä¼šå…ˆç»è¿‡è¿™é‡Œã€‚
// å¦‚æœ Token æ— æ•ˆï¼Œç›´æ¥æ‹’ç»è¯·æ±‚ï¼Œä»£ç éƒ½ä¸ä¼šè¿›å…¥ handlerã€‚

pub struct AuthUser {
    pub id: i32,      // åŒ…å« ID
    pub username: String,
}

#[async_trait]
impl<S> FromRequestParts<S> for AuthUser
where
    S: Send + Sync,
{
    type Rejection = AppError;

    async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
        // 1. ä» Header æå– Bearer Token
        let TypedHeader(Authorization(bearer)) = parts
            .extract::<TypedHeader<Authorization<Bearer>>>()
            .await
            .map_err(|_| AppError::Auth("Missing or invalid token".into()))?;

        // 2. éªŒè¯ Token
        let secret = std::env::var("JWT_SECRET").unwrap_or_else(|_| "secret".into());
        let token_data = decode::<Claims>(
            bearer.token(),
            &DecodingKey::from_secret(secret.as_bytes()),
            &Validation::new(Algorithm::HS256),
        )
        .map_err(|_| AppError::Auth("Invalid token".into()))?;

        // 3. éªŒè¯é€šè¿‡ï¼Œè¿”å› AuthUser
        Ok(AuthUser {
            id: token_data.claims.sub,
            username: token_data.claims.username,
        })
    }
}
</file>

<file path="src/main.rs">
// src/main.rs
use axum::{
    routing::{get, post, patch, delete}, // å¼•å…¥æ›´å¤šè·¯ç”±æ–¹æ³•
    Router,
    http::{Method, HeaderValue}, // å¼•å…¥ Method å’Œ HeaderValue
};
use tower_http::cors::{CorsLayer, Any}; // å¼•å…¥ CORS ç›¸å…³
use sqlx::postgres::PgPoolOptions;
use sqlx::PgPool;
use std::net::SocketAddr;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

// å¼•å…¥æ¨¡å—
mod handlers;
mod models;
mod auth;
mod error; // å¼•å…¥æ–°æ¨¡å—
pub use error::AppError; // å¯¼å‡ºæ–¹ä¾¿å…¶ä»–åœ°æ–¹ä½¿ç”¨
mod validation; // <--- æ·»åŠ è¿™ä¸€è¡Œï¼Œè®©ç¼–è¯‘å™¨çŸ¥é“ validation.rs çš„å­˜åœ¨

// ä½¿ç”¨ handlers ä¸­çš„å‡½æ•°
use handlers::{
    create_plan_handler, delete_plan_handler, get_plans_handler, update_plan_handler,
    login_handler, register_handler
};

#[derive(Clone)]
pub struct AppState { // æ³¨æ„åŠ ä¸Š pubï¼Œå› ä¸º handlers é‡Œè¦ç”¨
    pub db: PgPool,   // æ³¨æ„åŠ ä¸Š pub
}

#[tokio::main]
async fn main() {
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| "debug".into()))
        .with(tracing_subscriber::fmt::layer())
        .init();

    dotenvy::dotenv().ok();
    let db_url = std::env::var("DATABASE_URL").expect("DATABASE_URL must be set in .env");

    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&db_url)
        .await
        .expect("Failed to connect to Postgres");

    tracing::info!("âœ… æˆåŠŸè¿æ¥åˆ°æ•°æ®åº“!");

    let state = AppState { db: pool };

        // --- CORS é…ç½® (å…³é”®æ­¥éª¤) ---
    // å…è®¸å‰ç«¯ (http://localhost:5173) è®¿é—®åç«¯
    let cors = CorsLayer::new()
        // å…è®¸çš„æ¥æºï¼šä¸ºäº†å¼€å‘æ–¹ä¾¿ï¼Œè¿™é‡Œå…ˆè®¾ä¸º Any (å…è®¸æ‰€æœ‰)ï¼Œ
        // ç”Ÿäº§ç¯å¢ƒå»ºè®®æ”¹ä¸º specific origin: "http://localhost:5173".parse::<HeaderValue>().unwrap()
        .allow_origin(Any) 
        // å…è®¸çš„æ–¹æ³•
        .allow_methods([Method::GET, Method::POST, Method::PATCH, Method::DELETE])
        // å…è®¸çš„å¤´ (Authorization ç­‰)
        .allow_headers(Any);

    // å®šä¹‰è·¯ç”±
    let app = Router::new()
        // å…¬å¼€è·¯ç”±
        .route("/api/plans", get(get_plans_handler))
        .route("/api/register", post(register_handler)) // æ³¨å†Œ
        .route("/api/login", post(login_handler))       // ç™»å½•
        // å—ä¿æŠ¤è·¯ç”± (åœ¨ handlers å†…éƒ¨é€šè¿‡ AuthUser å‚æ•°ä¿æŠ¤ï¼Œè¿™é‡Œè·¯ç”±å†™æ³•çœ‹èµ·æ¥ä¸€æ ·)
        .route("/api/plans", post(create_plan_handler))
        .route("/api/plans/:id", patch(update_plan_handler))
        .route("/api/plans/:id", delete(delete_plan_handler))
        .with_state(state)
        .layer(cors);

    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    tracing::info!("ğŸš€ æœåŠ¡å™¨æ­£åœ¨ç›‘å¬: {}", addr);

    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}
</file>

<file path="src/error.rs">
// src/error.rs
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::{json, Value};
use thiserror::Error;
use validator::ValidationErrors;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("Database error")]
    Database(#[from] sqlx::Error),

    #[error("Authentication failed: {0}")]
    Auth(String),

    #[error("Not found")]
    NotFound(String),

    #[error("Internal server error")]
    Internal,

    #[error("Validation error")]
    ValidationError(#[from] ValidationErrors),

    #[error("Bad request: {0}")]
    BadRequest(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, message, details) = match self {
            AppError::Database(ref e) => {
                tracing::error!("DB Error: {:?}", e);
                if e.to_string().contains("duplicate key") {
                    (StatusCode::CONFLICT, "è®°å½•å·²å­˜åœ¨".to_string(), None)
                } else {
                    (
                        StatusCode::INTERNAL_SERVER_ERROR,
                        "æ•°æ®åº“æ“ä½œå¤±è´¥".to_string(),
                        None,
                    )
                }
            }
            AppError::Auth(msg) => (StatusCode::UNAUTHORIZED, msg, None),
            AppError::NotFound(msg) => (StatusCode::NOT_FOUND, msg, None),
            AppError::ValidationError(e) => {
                // å°† validator çš„é”™è¯¯æå–ä¸º field -> message çš„ Map
                let mut errors = std::collections::HashMap::new();
                for (field, field_errors) in e.field_errors() {
                    let msgs: Vec<String> = field_errors
                        .iter()
                        .map(|fe| {
                            fe.message
                                .as_ref()
                                .map(|m| m.to_string())
                                .unwrap_or_else(|| "æ ¼å¼ä¸æ­£ç¡®".to_string())
                        })
                        .collect();
                    errors.insert(field, msgs);
                }
                (
                    StatusCode::BAD_REQUEST,
                    "è¾“å…¥æ ¡éªŒå¤±è´¥".to_string(),
                    Some(json!(errors)),
                )
            }
            AppError::BadRequest(msg) => (StatusCode::BAD_REQUEST, msg, None),
            AppError::Internal => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "æœåŠ¡å™¨å†…éƒ¨é”™è¯¯".to_string(),
                None,
            ),
        };

        let body = Json(json!({
            "status": "error",
            "message": message,
            "errors": details // è¿™é‡Œçš„å…·ä½“é”™è¯¯å­—æ®µä¾›å‰ç«¯è§£æ
        }));

        (status, body).into_response()
    }
}
</file>

<file path="src/handlers.rs">
// src/handlers.rs
use crate::auth::{create_jwt, hash_password, verify_password, AuthUser}; // å¼•å…¥ AuthUser
use crate::models::{
    AuthResponse,
    CreatePlanSchema,
    LoginSchema,
    Plan,
    RegisterSchema,
    UpdatePlanSchema,
    User, // <--- ç¡®ä¿å¼•å…¥ User
};
use crate::AppError;
use crate::AppState;
use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde_json::json; // <--- ä¿®å¤æŠ¥é”™ï¼šå¼•å…¥ json! å® // å¼•å…¥è‡ªå®šä¹‰é”™è¯¯
use crate::validation::ValidatedJson; // å¼•å…¥æˆ‘ä»¬çš„æå–å™¨
use axum::extract::Query; // å¼•å…¥ Query æå–å™¨
use crate::models::PlanQuery; // å¼•å…¥åˆšæ‰å®šä¹‰çš„ç»“æ„ä½“

// --- 1. è·å–åˆ—è¡¨ (GET /plans) ---
pub async fn get_plans_handler(
    auth: Option<AuthUser>, // å¯é€‰è®¤è¯ï¼šç™»å½•åèƒ½çœ‹åˆ°è‡ªå·±çš„ç§æœ‰è®¡åˆ’
    Query(query): Query<PlanQuery>, // è·å– URL å‚æ•°ï¼Œä¾‹å¦‚ ?q=rust&status=pending
    State(state): State<AppState>,
) -> Result<Json<Vec<Plan>>, AppError> {
    let user_id = auth.map(|u| u.id).unwrap_or(-1); // å¦‚æœæ²¡ç™»å½•ï¼Œuser_id è®¾ä¸ºä¸å¯èƒ½çš„å€¼

    // æ„å»ºåŠ¨æ€æŸ¥è¯¢ SQL
    // ILIKE æ˜¯ PostgreSQL çš„ä¸åŒºåˆ†å¤§å°å†™æ¨¡ç³ŠæŸ¥è¯¢
    let plans = sqlx::query_as::<_, Plan>(
        r#"
        SELECT * FROM plans 
        WHERE (is_public = 't' OR user_id = $1)
          AND ($2 IS NULL OR title ILIKE $2 OR description ILIKE $2)
          AND ($3 IS NULL OR status = $3)
          AND ($4 IS NULL OR category = $4)
        ORDER BY created_at DESC
        "#,
    )
    .bind(user_id)
    .bind(query.q.map(|s| format!("%{}%", s))) // åŒ…è£…æˆ SQL æ¨¡ç³ŠåŒ¹é…æ ¼å¼ %key%
    .bind(query.status)
    .bind(query.category)
    .fetch_all(&state.db)
    .await?;


    Ok(Json(plans))
}

// --- 2. åˆ›å»ºè®¡åˆ’ (POST /plans) ---
pub async fn create_plan_handler(
    user: AuthUser, // å¼ºåˆ¶è¦æ±‚ç™»å½•
    State(state): State<AppState>,
    ValidatedJson(body): ValidatedJson<CreatePlanSchema>, // è¿™é‡Œçš„ ValidatedJson ä¼šè‡ªåŠ¨æ ¡éªŒ
) -> Result<Json<Plan>, AppError> {

    // æ’å…¥æ•°æ® 
    let plan = sqlx::query_as::<_, Plan>(
        "INSERT INTO plans (title, description, category, priority, due_date, is_public, user_id) 
         VALUES ($1, $2, $3, $4, $5, $6, $7) 
         RETURNING *",
    )
    .bind(body.title)
    .bind(body.description)
    .bind(body.category)
    .bind(body.priority.unwrap_or(0)) // é»˜è®¤ä¸º 0
    .bind(body.due_date)
    .bind(body.is_public)
    .bind(user.id)
    .fetch_one(&state.db)
    .await?;
    Ok(Json(plan))
}

// --- 3. æ›´æ–°è®¡åˆ’ (PATCH /plans/:id) ---
pub async fn update_plan_handler(
    Path(id): Path<i32>,
    user: AuthUser,
    State(state): State<AppState>,
    ValidatedJson(body): ValidatedJson<UpdatePlanSchema>, // è‡ªåŠ¨æ ¡éªŒ
) -> Result<Json<Plan>, AppError> {
    // ä½¿ç”¨ fetch_optional æ¥åˆ¤æ–­æ›´æ–°æ˜¯å¦æˆåŠŸï¼ˆæ˜¯å¦æ‰¾åˆ°å±äºè¯¥ç”¨æˆ·çš„è®°å½•ï¼‰
    let plan = sqlx::query_as::<_, Plan>(
        "UPDATE plans SET 
            title = COALESCE($1, title),
            description = COALESCE($2, description),
            status = COALESCE($3, status),
            category = COALESCE($4, category),
            priority = COALESCE($5, priority), -- æ–°å¢
            due_date = COALESCE($6, due_date),
            is_public = COALESCE($7, is_public),
            updated_at = NOW()
         WHERE id = $8 AND user_id = $9
         RETURNING *",
    )
    .bind(body.title)
    .bind(body.description)
    .bind(body.status)
    .bind(body.category)
    .bind(body.priority) // $5
    .bind(body.due_date) // $6
    .bind(body.is_public)// $7
    .bind(id)            // $8
    .bind(user.id)       // $9
    .fetch_optional(&state.db)
    .await?
    .ok_or_else(|| AppError::NotFound("...".into()))?;

    Ok(Json(plan))
}

// --- 4. åˆ é™¤è®¡åˆ’ (DELETE /plans/:id) ---
pub async fn delete_plan_handler(
    Path(id): Path<i32>,
    user: AuthUser,
    State(state): State<AppState>,
) -> Result<StatusCode, AppError> {
    let result = sqlx::query("DELETE FROM plans WHERE id = $1 AND user_id = $2")
        .bind(id)
        .bind(user.id)
        .execute(&state.db)
        .await?;

    // æ£€æŸ¥æ˜¯å¦æœ‰è¡Œè¢«åˆ é™¤
    if result.rows_affected() == 0 {
        return Err(AppError::NotFound(
            "Plan not found or you don't have permission".to_string(),
        ));
    }

    Ok(StatusCode::NO_CONTENT) // 204 No Content
}

// --- 5. ç”¨æˆ·æ³¨å†Œ ---
pub async fn register_handler(
    State(state): State<AppState>,
    ValidatedJson(payload): ValidatedJson<RegisterSchema>, // è‡ªåŠ¨æ ¡éªŒ
) -> Result<Json<serde_json::Value>, AppError> {
    // 1. å“ˆå¸Œå¯†ç 
    // ä¿®å¤æŠ¥é”™ï¼šä½¿ç”¨ map_err å°† String é”™è¯¯è½¬æ¢ä¸º (StatusCode, String)
    let hashed_password =
        hash_password(&payload.password).map_err(|e| AppError::Internal)?; // è½¬æ¢åŠ å¯†åº“çš„é”™è¯¯

    // 2. å­˜å…¥æ•°æ®åº“
    let _ = sqlx::query("INSERT INTO users (username, password_hash) VALUES ($1, $2)")
        .bind(&payload.username)
        .bind(hashed_password)
        .execute(&state.db)
        .await?;

    Ok(Json(json!({"message": "User registered successfully"})))
}

// --- 6. ç”¨æˆ·ç™»å½• ---
pub async fn login_handler(
    State(state): State<AppState>,
    Json(payload): Json<LoginSchema>,
) -> Result<Json<AuthResponse>, AppError> {
    // 1. æŸ¥æ‰¾ç”¨æˆ·
    let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE username = $1")
        .bind(&payload.username)
        .fetch_optional(&state.db)
        .await?
        .ok_or_else(|| AppError::Auth("Invalid username or password".into()))?;

    // 2. éªŒè¯å¯†ç 
    if !verify_password(&payload.password, &user.password_hash) {
        return Err(AppError::Auth("Invalid username or password".into()));
    }

    // 3. ç”Ÿæˆ Token
    // ä¿®å¤æŠ¥é”™ï¼šä½¿ç”¨ map_err å°† String é”™è¯¯è½¬æ¢ä¸º (StatusCode, String)
    let token =
        create_jwt(user.id, &user.username).map_err(|e| AppError::Internal)?;

    Ok(Json(AuthResponse {
        token,
        username: user.username,
    }))
}
</file>

<file path="src/models.rs">
// src/models.rs
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::FromRow;
use validator::Validate; // å¼•å…¥ Validate trait

// --- 1. User æ¨¡å‹ (æ•°æ®åº“å¯¹åº”) ---
#[derive(Debug, FromRow, Deserialize, Serialize)]
pub struct User {
    pub id: i32,
    pub username: String,
    #[serde(skip)] // åºåˆ—åŒ–æ—¶è·³è¿‡å¯†ç 
    pub password_hash: String,

    pub created_at: Option<DateTime<Utc>>,
}

// --- 2. Plan æ¨¡å‹ (æ•°æ®åº“å¯¹åº”) ---
#[derive(Debug, FromRow, Serialize)]
pub struct Plan {
    pub id: i32,
    pub user_id: i32, // æ–°å¢å­—æ®µ
    pub title: String,
    pub description: Option<String>,
    pub status: String,
    pub category: Option<String>,
    pub priority: i32,
    pub due_date: Option<DateTime<Utc>>,
    pub is_public: bool,
    pub created_at: Option<DateTime<Utc>>,
    pub updated_at: Option<DateTime<Utc>>,
}

// --- 3. CRUD è¯·æ±‚ç»“æ„ä½“ ---
#[derive(Debug, Deserialize, Validate)]
pub struct CreatePlanSchema {
    #[validate(length(min = 1, max = 150, message = "æ ‡é¢˜ä¸èƒ½ä¸ºç©ºä¸”ä¸èƒ½è¶…è¿‡ 150 å­—"))]
    pub title: String,
    #[validate(length(min = 5, message = "æè¿°å†…å®¹è‡³å°‘éœ€è¦ 5 ä¸ªå­—"))]
    pub description: Option<String>,
    #[validate(length(max = 50, message = "åˆ†ç±»åç§°è¿‡é•¿"))]
    pub category: Option<String>,
    pub priority: Option<i32>,
    pub due_date: Option<DateTime<Utc>>,
    #[serde(default = "default_is_public")]
    pub is_public: bool,
}

fn default_is_public() -> bool {
    true
}

#[derive(Debug, Deserialize, Validate)]
pub struct UpdatePlanSchema {
    // æ›´æ–°æ—¶ï¼Œå¦‚æœä¼ äº†æ ‡é¢˜ï¼Œåˆ™å¿…é¡»æ»¡è¶³é•¿åº¦
    #[validate(length(min = 2, max = 150, message = "æ ‡é¢˜è‡³å°‘éœ€è¦ 2 ä¸ªå­—"))]
    pub title: Option<String>,
    // ä¿®å¤ç‚¹ï¼šå¢åŠ æè¿°æ ¡éªŒï¼Œç¡®ä¿æ›´æ–°æ—¶å¦‚æœä¿®æ”¹äº†æè¿°ï¼Œé•¿åº¦ä¹Ÿè¦å¤Ÿ
    #[validate(length(min = 5, message = "æè¿°å†…å®¹å¤ªçŸ­äº†ï¼Œè‡³å°‘ 5 ä¸ªå­—"))]
    pub description: Option<String>,
    pub status: Option<String>,
    pub category: Option<String>,
    pub priority: Option<i32>,
    pub due_date: Option<DateTime<Utc>>,
    pub is_public: Option<bool>,
}

// --- 4. è®¤è¯ç›¸å…³ç»“æ„ä½“ ---
#[derive(Debug, Deserialize, Validate)]
pub struct RegisterSchema {
    #[validate(length(min = 3, max = 20, message = "ç”¨æˆ·åé•¿åº¦éœ€åœ¨ 3-20 ä½ä¹‹é—´"))]
    pub username: String,
    #[validate(length(min = 6, message = "å¯†ç è‡³å°‘éœ€è¦ 6 ä½"))]
    pub password: String,
}

#[derive(Debug, Deserialize, Validate)]
pub struct LoginSchema {
    pub username: String,
    pub password: String,
}

#[derive(Debug, Serialize)]
pub struct AuthResponse {
    pub token: String,
    pub username: String,
}

#[derive(Debug, Deserialize)]
pub struct PlanQuery {
    pub q: Option<String>,        // æœç´¢å…³é”®è¯
    pub status: Option<String>,   // çŠ¶æ€è¿‡æ»¤
    pub category: Option<String>, // åˆ†ç±»è¿‡æ»¤
}
</file>

</files>
